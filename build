#! /usr/bin/python3
# Author: Richard A
# Last modified: 2020 02 12
# Status: Functional
# script to build firmware from dynamic dependancies. Prevents everything
# from being compiled, allows different demo dependancies to have 
# actual meaning.

import os, sys

main_name = "demo_blink"
if __name__ == "__main__":
    if len(sys.argv) > 1:
        main_name = sys.argv[1]
        print(f"=== building {main_name} ===")
        if "." in main_name:
            main_name = main_name.split(".")[0]
    elif len(sys.argv) == 1:
        print(f"=== building {main_name} ===")


compiler="arm-none-eabi-gcc"
main_root = "src/main/"
rel_path_sig = ". "
tivaware_location="../TivaWare_C_Series-2.1.4.178"
tmp_filename = "/tmp/compile_output.txt"
source_folders = os.listdir("src")
main_path = main_root + main_name + ".c"
total_dependancies = set([main_path])

def in_firmware(line):
    if tivaware_location in line:
        return False
    if len(line.split("/")) < 3:
        # print(line)
        return False
    elif line.split("/")[-2] in source_folders:
        return True
    return False

def get_raw_filename(line):
    split_path = line.split("/")
    fname = "src/" + split_path[-2] + "/" + split_path[-1].split(".")[0] + ".c"
    return fname

def get_dependancies_from_headers(file_to_check):
    # print("checking:",file_to_check)
    file_dependancies = set()
    command_string = f"{compiler} -H {file_to_check} -I{tivaware_location} 2>{tmp_filename}"
    os.system(command_string)

    with open(tmp_filename, 'r') as fp:
        # d_file_content = fp.read()
        for line in fp:
            # print(line)
            if in_firmware(line):
                file_name = get_raw_filename(line)
                # print("\t",file_name)
                file_dependancies.add(file_name)
    # input()
    return file_dependancies


def get_dependancies_from_makerules(file_to_check):
        # print("checking:",file_to_check)
    file_dependancies = set()
    command_string = f"{compiler} -MM {file_to_check} -I{tivaware_location} >{tmp_filename}"
    os.system(command_string)

    with open(tmp_filename, 'r') as fp:
        d_file_content = fp.read()
        for line in d_file_content.split(" "):
            # print(line)
            if in_firmware(line):
                file_name = get_raw_filename(line)
                # print("\t",file_name)
                file_dependancies.add(file_name)
    # input()
    return file_dependancies



# new plan is to generate the dependancies until no more can be generated and
# then build the sources list and rule from the set.
method = get_dependancies_from_headers

previous_dependancy_length = -1
new_depedancy_length = 0
loop_counter = 0
while new_depedancy_length > previous_dependancy_length and loop_counter<1000:
    previous_dependancy_length = new_depedancy_length
    new_dependancies = set()
    for file_ in total_dependancies:
        new_dependancies |= method(file_)
    total_dependancies |= new_dependancies
    new_depedancy_length = len(total_dependancies)
    loop_counter += 1

if loop_counter > 999:
    raise ValueError("Dependancy finder has broken, 1000 searches performed")
# print(total_dependancies)
total_dependancies.remove(main_path)
# instead of trying to fill a string in a makefile (dumb), add a dependancy
# file that's included at the top. (smort)

# generate firmware sources & custom rule from set:
firmware_sources = ""
final_custom_rule = f"{main_root}{main_name}.o: "
for source_file in total_dependancies:
    firmware_sources += f"{source_file} "
    final_custom_rule += f"{source_file[:-2]}.o "

with open("builds/firmware_sources.mk", 'w') as fw_srcs_mkfile:
    fw_srcs_mkfile.write(f"FW_SRCS={firmware_sources}")

# custom rule isn't neccisary, however, the ability to make it has been
# left here for future reference. Also, uncomment the incliude line in
# the makefile.
with open("builds/custom_rule.mk", 'w') as custom_rule_mkfile:
    custom_rule_mkfile.write(final_custom_rule)

make_command = f"make builds/{main_name}.out MAINFILE={main_name}"
os.system(make_command)

